empty - функция проверки переменной на пустоту. (переменная будет пустая, если она равна нулю, '' (пустой строке),
         false или null (то есть не определена ранее).

isset - функция проверяет существует ли переменная (то есть то, что она не равна null).

$week = ['пн', 'вт', 'ср', 'чт', 'пт', 'сб', 'вс'];
$week = [1=>'пн', 'вт', 'ср', 'чт', 'пт', 'сб', 'вс'];
$month = [1=>'янв', 'фев', 'мар', 'апр', 'май', 'июн', 'июл', 'авг', 'сен', 'окт', 'ноя', 'дек'];

echo '<pre>';
var_dump($a);
echo '</pre>';

abs - функция abs вычисляет модуль числа (то есть из отрицательного делает положительное).
abs(число);

sqrt - функция sqrt находит квадратный корень числа.
sqrt(число);

pow - функция pow возводит число в заданную степень.
pow(число, степень);

round - функция round округляет число по правилам математического округления.
round(число, [сколько знаков оставить в дробной части]);

ceil - функция ceil округляет дробь в большую сторону до целого.
ceil(число);

floor - функция floor округляет дробь в меньшую сторону.
floor(число);

min - функция min находит самое маленькое число из переданных ей параметрами или самое маленькое число среди элементов массива.
min(первое число, второе число....);
min(массив чисел);

max - функция max находит самое большое число из переданных ей параметрами или самое большое число среди элементов массива.
max(первое число, второе число....);
max(массив чисел);

mt_rand - Функция mt_rand генерирует случайное целое число в заданном промежутке.
mt_rand(с какого числа, до какого числа);

Вам также может пригодиться функция mt_getrandmax, которая возвращает наибольшее возможное случайное значение числа. 

////////////////////////////////////////////////////////////
strtolower - функция strtolower преобразовывает строку в нижний регистр.
strtolower(строка);

strtoupper - функция strtoupper преобразовывает строку в верхний регистр.
strtoupper(строка);

ucfirst - функция ucfirst преобразует первый символ строки 
        в верхний регистр. Не работает с кириллицей.
ucfirst(строка);

lcfirst - функция lcfirst преобразует первый символ строки
        в нижний регистр. Не работает с кириллицей.
lcfirst(строка);

ucwords - функция ucwords преобразует первый символ каждого слова
        в строке в верхний регистр. Не работает с кириллицей.
ucwords(строка);

strlen - функция strlen возвращает длину строки 
        (количество символов в строке).
        Данная функция неправильно работает с кириллицей. 
        Используйте функцию mb_strlen (она работает аналогичным образом, 
        но корректно обрабатывает кириллицу).
strlen(строка);

substr - функция substr вырезает и возвращает подстроку из строки.
        Сама строка при этом не изменяется. 
        Нумерация символов строки начинается с нуля.
        Второй параметр может быть отрицательным - в этом случае отсчет 
        начнется с конца строки, при этом последний символ будет 
        иметь номер -1.
        Последний параметр можно не указывать - в этом случае отрезание 
        произойдет до конца строки.
        Данная функция неправильно работает с кириллицей. 
        Используйте функцию mb_substr (она работает аналогичным образом,
        но корректно обрабатывает кириллицу).
substr(строка, откуда, [сколько]);

str_replace -  функция str_replace ищет в строке заданный текст и 
            меняет его на другой.
            Первым параметром функции принимает что меняем, а вторым - 
            на что меняем. Это могут быть две строки или два массива.
            Во втором случае соответствующие элементы одного массива 
            заменятся на соответствующие элементы второго массива 
            (см. примеры).
            Есть также функция str_ireplace, которая делает тоже самое, 
            но без учета регистра.
str_replace(что меняем, на что меняем, где меняем);

strtr - функция strtr осуществляет поиск и замену символов в строке.
        Функция имеет два варианта работы.
        В первом варианте функция принимает массив замен:
        ключами служит то, что мы меняем, 
        а значениями - на что будем менять:
strtr(где меняем, массив замен);

        Во втором варианте функция одним параметром принимает строку 
        с символами, которые будут заменены, а другим параметром строку 
        с символами, на которые будет производится замена.
        Соответствующие символы первой строки будут заменены на 
        соответствующие символы второй строки:
strtr(где меняем, что меняем, на что меняем);

substr_replace - функция substr_replace заменяет указанную часть 
                строки на другую.
substr_replace(где меняем, на что меняем, с какого символа, [сколько символов]);

strpos - функция strpos возвращает позицию первого вхождения подстроки 
        в другую строку. Первым параметром функция принимает строку, 
        в которой осуществляется поиск, вторым параметром - подстроку, 
        которую следует искать. 
strpos(где ищем, что ищем, [откуда искать]);

strstr - функция strstr находит первое вхождение подстроки 
        в строку и возвращает часть строки начиная этого места 
        до конца строки. В отличие от strchr ищет вхождение подстроки 
        из нескольких символов, а не вхождение одного символа.
strstr(где ищем, что ищем);

explode - функция explode разбивает строку в массив по определенному разделителю.
explode(разделитель, строка);

implode - функция implode сливает массив в строку с указанным разделителем.
implode(разделитель, строка);

str_split - функция str_split разбивает строку в массив.
str_split(строка, количество символов в элементе массива);

trim - функция trim удаляет пробелы с начала и конца строки. 
        Может также удалять другие символы, если их указать вторым параметром.
trim(строка);
trim(строка, символы);

ltrim - функция ltrim удаляет пробелы с начала строки.
rtrim - функция rtrim удаляет пробелы с конца строки.

strrev - функция strrev переворачивает строку так, чтобы символы шли в обратном порядке.
strrev(строка);

str_shuffle - функция str_shuffle переставляет символы в строке в случайном порядке.
str_shuffle(cтрока);

number_format - функция number_format позволяет форматировать число.
        Функция принимает один, два или четыре параметра (не три).
number_format(число);
number_format(число, количество знаков дробной части);
number_format(число, количество знаков дробной части, разделитель дробной части, разделитель тысяч);

str_repeat - функция str_repeat повторяет строку заданное количество раз.
str_repeat(строка, сколько раз повторить);

htmlspecialchars - функция htmlspecialchars позволяет вывести теги в 
            браузер так, чтобы он не считал их командами, 
            а выводил как строки.
htmlspecialchars(строка);

strip_tags - функция strip_tags удаляет HTML теги из строки 
            (не трогая их содержимого). 
            Вторым необязательным параметром можно указать 
            разрешенные теги - они не будут удалены. 
            Их указываем в таком формате: '<b>' или '<b><p>', 
            если хотим оставить несколько тегов.
strip_tags(строка, [разрешенные теги]);

chr - функция chr находит символ по его ASCII коду.
chr(код символа);

ord - функция ord возвращает ASCII код символа. Параметром 
        принимает один символ или целую строку 
        (в этом случае возвращает код ее первого символа).

str_word_count - функция str_word_count подсчитывает количество слов в строке.
        Функция может принимать второй необязательный параметр, число 1 или 2.
        Если он не задан, то возвращается целое число, 
        равное количеству слов.
        Если передано 1, то возвращается массив, содержащий все слова, 
        входящие в строку.
        Если передано 2, то возвращается массив, ключами которого являются 
        позиции в строке, а значениями - соответствующие слова.
str_word_count(строка, [число]);

substr_count - функция substr_count подсчитывает 
        сколько раз встречается подстрока в строке.
substr_count(строка, подстрока);

count_chars -  функция count_chars подсчитывает сколько раз встречаются 
        различные символы в строке.
        Первым параметром функция принимает строку, а вторым 
        необязательным параметром - модификатор, который изменяет 
        работу функции:
        0 - массив, индексами которого являются ASCII коды, 
            а значениями - число вхождений соответствующего символа.
        1 - то же, что и для 0, но информация о символах с нулевым числом 
            вхождений не включается в массив.
        2 - то же, что и для 0, но в массив включается информация 
            только о символах с нулевым числом вхождений.
        3 - строка, состоящая из символов, которые входят в исходную 
            строку хотя бы раз.
        4 - строка, состоящая из символов, которые не входят в исходную 
            строку.
        По умолчанию функция ведет себя так, будто второй параметр 
        поставлен в 0.
count_chars(строка, [модификатор]);

strchr - функция strchr находит первое вхождение подстроки в строку 
        и возвращает часть строки начиная этого места до конца строки.
strchr(где ищем, что ищем);

strrchr - функция strrchr находит последнее вхождение символа в строку
        и возвращает часть строки начиная этого места до конца строки.
strrchr(где ищем, что ищем);

strstr -  функция strstr находит первое вхождение подстроки в строку 
        и возвращает часть строки начиная этого места до конца строки. 
        В отличие от strchr ищет вхождение подстроки из нескольких символов, 
        а не вхождение одного символа.
strstr(где ищем, что ищем);

Есть также функция stristr, которая делает тоже самое, но без учета регистра. 
////////////////////////////////////////////////////////////
count - подсчитывает количество элементов массива;
count(массив);

unset — Удаляет переменную

in_array - проверяет наличие заданного элемента в массиве;
in_array(что искать, в каком массиве);

array_sum - вычисляет сумму элементов массива;
array_sum(массив);

array_product - вычисляет произведение (умножение) элементов массива;
array_product(массив);

range - создает массив с диапазоном элементов;
range(откуда, докуда, [шаг]);

array_merge - сливает два и более массивов вместе;
array_merge(первый массив, второй массив...);

array_slice - отрезает и возвращает часть массива (не меняет массив);
array_slice(массив, откуда отрезать, [сколько], [сохранять ключи = false]);

array_splice - отрезает и возвращает часть массива (меняет массив);
array_splice(массив, откуда отрезать, [сколько], [вставить взамен]);

array_keys - получает ключи массива и записывает их в новый массив;
array_keys(массив);

array_values - выбирает все значения из массива;
array_values(массив);

array_combine - осуществляет слияние двух массивов в один ассоциативный;
array_combine(массив ключей, массив значений);

array_flip - производит обмен местами ключей и значений массива;
array_flip(массив);

array_reverse - переворачивает массив в обратном порядке;
array_reverse(массив, [сохранять ли ключи]);

array_search - осуществляет поиск значения в массиве и возвращает 
        ключ первого найденного элемента;
array_search(что ищем, где ищем, [сравнивать по типу = false]);

array_replace - заменяет значения первого массива значениями с 
        такими же ключами из других переданных массивов;
array_replace(массив, массив, массив...);

array_count_values - производит подсчет количества всех значений массива;
array_count_values(массив);

Сортировка массивов:
sort - по возрастанию элементов,
rsort - по убыванию элементов, 
asort - по возрастанию элементов с сохранением ключей,
arsort - по убыванию элементов с сохранением ключей,
ksort - по возрастанию ключей, 
krsort - по убыванию ключей, 
usort - по функции по элементам, 
uasort - по функции по элементам с сохранением ключей,
uksort - по функции по ключам,
natsort - натуральная сортировка.

array_rand - возвращает случайный ключ из массива;
array_rand(массив, [сколько ключей выбрать]);

shuffle - перемещать массив (случайно)

array_unique - осуществляет удаление повторяющихся элементов (дублей)
        из массива;
array_unique(массив);

array_shift - вырезает и возвращает первый элемент массива. 
        При этом этот элемент исчезает из массива;
array_shift(массив);

array_pop - вырезает и возвращает последний элемент массива.
        При этом этот элемент исчезает из массива.
array_pop(массив);

array_unshift - добавляет элементы в начало массива
array_unshift(массив, какие элементы добавить);

array_push - добавляет элементы в конец массива;
array_push(массив к которому добавить элементы, какие элементы добавить);

array_pad - дополняет массив определенным значением до заданного размера.
array_pad(массив, до какого размера заполнить, чем заполнять);

array_fill - создает массив, заполненный элементами 
        с определенным значением.
array_fill(ключ первого элемента, сколько элементов, чем заполнять);

array_fill_keys - создает массив и заполняет массив элементами 
        с определенным значением так, чтобы весь массив был 
        с одинаковыми элементами, но разными ключами. 
        Ключи берутся из массива, передаваемого первым параметром.
array_fill_keys(ключ первого элемента, сколько элементов, чем заполнять);

array_chunk - разбивает одномерный массив в двухмерный. 
        Первым параметром она принимает массив, 
        а вторым - количество элементов в каждом подмассиве.
array_chunk(массив, по сколько элементов);

array_map - применяет заданную функцию ко всем элементам массива
         и возвращает измененный массив;
array_map(имя функции в кавычках, массив, [еще массивы через запятую]);

array_intersect - вычисляет пересечение массивов - возвращает массив
         из элементов, которые есть во всех массивах, переданных в функцию.
array_intersect(массив, массив, массив...);

array_diff - возвращает массив из элементов, которые не являются
         общими для первого массива, переданных в функцию.
array_diff(массив, массив, массив...);

////////////////////////////////////////////////////////////

Функция time - возвращает разницу в секундах между 1-го января 1970 года 
        и текущим моментом времени. Такое представление даты называется 
        форматом timestamp.
        С помощью функции time мы можем получить только текущий момент времени

Функция mktime - время на определенное время. Параметры можно опускать с конца.
mktime(час, минута, секунда, месяц, день, год)

Функция date - выводит текущие дату и время в заданном формате. 
        Формат задается управляющими командами (английскими буквами), 
        при этом можно вставлять любые разделители между ними 
        (дефисы, двоеточие и так далее).

        date('d-m-Y', mktime(0, 0, 0, 12, 29, 13));
        имеет второй необязательный параметр, который принимает момент времени 
        в формате timestamp. Если передать этот параметр, то функция date отформатирует
        не текущий момент времени, а тот, который передан вторым параметром. 
        Этот timestamp можно получить, к примеру, через mktime (но не обязательно).
&& date('n', $time) == '13'
 Команды (заглавные буквы отличаются от обычных, обратите внимание!):
    U – количество секунд, прошедших с 1 января 1970 года (то есть timestamp).
    z – номер дня от начала года.
    Y – год, 4 цифры.
    y - год, две цифры.
    m – номер месяца (с нулем спереди).
    n – номер месяца без нуля впереди.
    d – номер дня в месяце, всегда две цифры (то есть первая может быть нулем).
    j – номер дня в месяце без предваряющего нуля.
    w – день недели (0 - воскресенье, 1 - понедельник и т.д.).
    h – часы в 12-часовом формате.
    H – часы в 24-часовом формате.
    i – минуты.
    s – секунды.
    L – 1, если високосный год, 0, если не високосный.
    W – порядковый номер недели года.
    t – количество дней в указанном месяце.

Функция strtotime - это аналог функции mktime (тоже возвращает timestamp), 
        только в отличие от нее принимает дату в более свободном формате.
Можно передать ей строку '2025-12-31' и функция сама разберет, где тут год, 
        где месяц, а где день.
можно написать так - strtotime('now') - и мы получим текущий момент времени, 
        или так - strtotime('next Monday') - и мы получим следующий понедельник 
        (Monday по-английски 'понедельник').
И т.п.

Как добавить или отнять дату
Чтобы отнять или прибавить к дате определенный промежуток времени, 
следует пользоваться комбинацией из трех функций:

date_create - она подготавливает дату к работе (дата должна быть в формате 
        год-месяц-день) создавая так называемый объект дата, 
        с которым производятся дальнейшие манипуляции. date_create('2025-12-31')
date_modify - она прибавляет или отнимает. date_modify($date, '3 days');
date_format - она выводит получившуюся дату в заданном формате. date_format($date, 'd.m.Y')

////////////////////////////////////////////////////////////
preg_replace - эта функция очень похожа на 
        str_replace – тоже осуществляет поиск и замену, 
        только первым параметром принимается не просто строка,
        а регулярное выражение

        preg_replace(что меняем, на что меняем, где меняем)
        echo preg_replace('#a#', '!', 'aabbaa'); //выведет '!!bb!!'

        # - модификатор
        i - заставит игнорировать регистр
                echo preg_replace('#A#i', '!', 'aAb'); //выведет '!!b'

preg_match - которая проверяет, есть ли в строке совпадение с регуляркой
                ищет только одно совпадение.
        preg_match(регулярка, где искать)

preg_match_all - ищет все совпадения
        preg_match_all(регулярка, где искать, найденное)
                третий параметр: туда можно записать переменную, 
                к которую сложатся все найденные совпадения (в виде массива)
////////////////////////////////////////////////////////////
//чтение файл в строку
file_get_contents('файл');

//создание файла и(или) внесение текста в файл
file_put_contents('файл', 'текст файла');

//копирование файла
copy('файл');

//переименование и перемещение файла или папки
rename('файл');

//удаление файла
unlink('файл');

//проверка существования файла
file_exists('файл');

//узнать размер файла
filesize('файл');

//константа переноса строки в каждой ОС разная (Windows-\r\n, Linux-\n, MacOS-\r)
PHP_EOL

//читает содержимое файла и помещает его в массив
 file ( string $filename , int $flags = 0 , resource $context = ? ) : array

 //создание папки
 mkdir('название_папки');

 //удаление папки
 mrdir('название_папки');

 //создать массив значений папки (не сканирует подпапки)
 scandir('папка');

//проверка на файл
 is_file('значение');

 //проверка на папку
 is_dir('значение');

 //функция glob - поиск файла по шаблону, возвращает массив имён файлов
 // * - несколько символов
 // ? - один символ

 glob('dir/*.txt'); или
 glob('dir/?.txt');

////////////////////////////////////////////////////////////
//Устанавливаем доступы к базе данных:
$host = 'localhost'; //имя хоста, на локальном компьютере это localhost
$user = 'root'; //имя пользователя, по умолчанию это root
$password = ''; //пароль, по умолчанию пустой
$db_name = 'test'; //имя базы данных

//Соединяемся с базой данных используя наши доступы:
mysqli_connect($host, $user, $password, $db_name) or die(mysqli_error($link));

//Устанавливаем кодировку (не обязательно, но поможет избежать проблем):
mysqli_query($link, "SET NAMES 'utf8'")

SELECT - выборка из БД
        SELECT * FROM имя_таблицы WHERE условие_по_которому_следует_выбрать_строки;
        SELECT * FROM workers WHERE id > 0
Более сложная логика: OR и AND
        SELECT * FROM workers WHERE salary=500 AND age=23
        SELECT * FROM workers WHERE salary=500 OR age=23
INSERT - вставка данных в БД
        INSERT INTO имя_таблицы SET поле1=значение1, поле2=значение2, поле3=значение3...;
        INSERT INTO workers SET name='Гена', age=30, salary=1000

        Другой синтаксис INSERT
        INSERT INTO workers (поле1, поле2...) VALUES (значение1, значение2...)
        INSERT INTO workers (name, age, salary) VALUES ('Гена', 30, 1000)

        Массовая вставка через INSERT
        INSERT INTO имя_таблицы (поле1, поле2...)
		VALUES (значение1, значение2...), (значение1, значение2...)...
        INSERT INTO workers (name, age, salary)
		VALUES ('Гена', 30, 1000), ('Вася', 25, 500), ('Иван', 27, 1500)
DELETE - удаление записей
        DELETE FROM имя_таблицы WHERE условие_по_которому_следует_удалять_строки
        DELETE FROM workers WHERE id=6
UPDATE - обновление значений записей
        UPDATE workers SET salary=1000 WHERE name='Дима'
ORDER BY - сортировка
        SELECT * FROM workers WHERE id>0 ORDER BY age
        SELECT * FROM workers WHERE id>0 ORDER BY age DESC - обр.порядковый
LIMIT — ограничение количества
        SELECT * FROM workers WHERE id>0 LIMIT 2
        SELECT * FROM workers WHERE id>0 LIMIT 2,5 - со 2-ой строки 5 штук
COUNT — считаем количество
        SELECT COUNT(*) as count FROM workers WHERE id>0
        COUNT(*) - без пробелом
LIKE - реализуем поиск
        SELECT * FROM workers WHERE name LIKE '%я'
        //ВЫБРАТЬ все ИЗ таблицы ГДЕ имя ПОДОБНО любой_строке_заканчивающейся_на_я
Кавычки ``
        проблемные слова следует брать в косые кавычки
        SELECT * FROM `from`
